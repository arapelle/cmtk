
include(${CMAKE_CURRENT_LIST_DIR}/Utility.cmake)

function(disable_in_source_build)
    file(REAL_PATH ${CMAKE_SOURCE_DIR} cmake_src_dir EXPAND_TILDE)
    file(REAL_PATH ${CMAKE_BINARY_DIR} cmake_bin_dir EXPAND_TILDE)
    string(FIND "${cmake_bin_dir}" "${cmake_src_dir}" index)
    if(${index} EQUAL 0)
        set(msg_details "CMAKE_SOURCE_DIR: ${CMAKE_SOURCE_DIR}\nCMAKE_BINARY_DIR: ${CMAKE_BINARY_DIR}")
        message(FATAL_ERROR "In source build is disabled!\nCMAKE_BINARY_DIR must not be located in CMAKE_SOURCE_DIR!\n${msg_details}")
    endif()
endfunction()

function(check_in_source_build)
    option(ENABLE_IN_SOURCE_BUILD "Enable (ON) or Disable (OFF) in source build." OFF)
    if(NOT ${ENABLE_IN_SOURCE_BUILD})
        disable_in_source_build()
    endif()
endfunction()

function(set_build_type_ifndef)
    # Args:
    set(options "")
    set(params "DEFAULT")
    set(lists "BUILD_TYPES")
    # Parse args:
    cmake_parse_arguments(PARSE_ARGV 0 "ARG" "${options}" "${params}" "${lists}")
    # Check args:
    if(NOT DEFINED ARG_BUILD_TYPES)
        set(ARG_BUILD_TYPES "Release" "Debug" "MinSizeRel" "RelWithDebInfo")
    endif()
    set_ifndef(ARG_DEFAULT 0)
    if (${ARG_DEFAULT} MATCHES "^[0-9]+$")
        list(GET ARG_BUILD_TYPES ${ARG_DEFAULT} ARG_DEFAULT)
    else()
        list(FIND ARG_BUILD_TYPES ${ARG_DEFAULT} index)
        if(index EQUAL -1)
            message(FATAL_ERROR "Build type '${ARG_DEFAULT}' is not valid: ${ARG_BUILD_TYPES}.")
        endif()
    endif()
    if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES)
      message(STATUS "Setting build type to '${ARG_DEFAULT}' as none was specified.")
      set(CMAKE_BUILD_TYPE "${ARG_DEFAULT}" CACHE STRING "Choose the type of build." FORCE)
      set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS ${ARG_BUILD_TYPES})
    endif()
endfunction()

function(_cmtk_set_name prefix)
    # Args:
    set(options "")
    set(params "NAME;NAMESPACE;SUBJECT_NAME;CODE_NAME;CODE_NAMESPACE;CODE_SUBJECT_NAME;")
    set(lists "")
    # Parse args:
    cmake_parse_arguments(PARSE_ARGV 0 "ARG" "${options}" "${params}" "${lists}")
    # Check args:
    fatal_ifdef("Use SUBJECT_NAME, not FEATURE_NAME or BASE_NAME." ARG_FEATURE_NAME ARG_BASE_NAME)
    fatal_if_none_is_def("NAME or SUBJECT_NAME is missing." ARG_NAME ARG_SUBJECT_NAME)
    if(DEFINED ARG_NAME)
        fatal_ifdef("NAMESPACE and SUBJECT_NAME must not be provided if NAME is provided." ARG_NAMESPACE ARG_SUBJECT_NAME)
        set(pj_name "${ARG_NAME}")
        set(${prefix}_NAME "${pj_name}" PARENT_SCOPE)
        set_ifndef(ARG_CODE_NAME "${ARG_NAME}")
        set(${prefix}_CODE_NAME "${ARG_CODE_NAME}" PARENT_SCOPE)
    else()
        fatal_ifndef("SUBJECT_NAME is provided but NAMESPACE is missing." ARG_NAMESPACE)
        set(${prefix}_NAMESPACE "${ARG_NAMESPACE}" PARENT_SCOPE)
        set(${prefix}_SUBJECT_NAME "${ARG_SUBJECT_NAME}" PARENT_SCOPE)
        set_ifndef(ARG_CODE_NAMESPACE "${ARG_NAMESPACE}")
        set_ifndef(ARG_CODE_SUBJECT_NAME "${ARG_SUBJECT_NAME}")
        set(${prefix}_CODE_NAMESPACE "${ARG_CODE_NAMESPACE}" PARENT_SCOPE)
        set(${prefix}_CODE_SUBJECT_NAME "${ARG_CODE_SUBJECT_NAME}" PARENT_SCOPE)
        set(pj_name "${ARG_NAMESPACE}-${ARG_SUBJECT_NAME}")
        set(${prefix}_NAME "${pj_name}" PARENT_SCOPE)
        set(${prefix}_CODE_NAME "${ARG_CODE_NAMESPACE}-${ARG_CODE_SUBJECT_NAME}" PARENT_SCOPE)
    endif()
    make_upper_c_identifier("${pj_name}" upper_var_name)
    set(${prefix}_UPPER_VAR_NAME "${upper_var_name}" PARENT_SCOPE)
    make_lower_c_identifier("${pj_name}" lower_var_name)
    set(${prefix}_LOWER_VAR_NAME "${lower_var_name}" PARENT_SCOPE)
endfunction()

macro(set_project_name)
    _cmtk_set_name("PROJECT" ${ARGV})
endmacro()

macro(set_package_name)
    _cmtk_set_name("PACKAGE" ${ARGV})
endmacro()

macro(set_component_name_if_build comp_name)
    # Args:
    set(options "RETURN_IF_NOT_BUILT")
    set(params "NAMESPACE;CODE_NAME;OPTION_NAME;OPTION_MSG;OPTION_DEFAULT;OUT_VAR")
    set(lists "")
    # Parse args:
    cmake_parse_arguments("M_ARG" "${options}" "${params}" "${lists}" ${ARGN})
    set_ifndef(M_ARG_NAMESPACE "${PACKAGE_NAME}")
    if(NOT DEFINED M_ARG_OPTION_NAME)
        if(M_ARG_NAMESPACE)
            make_upper_c_identifier("BUILD_${M_ARG_NAMESPACE}_${comp_name}" M_ARG_OPTION_NAME)
        else()
            make_upper_c_identifier("BUILD_${comp_name}" M_ARG_OPTION_NAME)
        endif()
    endif()
    if(NOT DEFINED M_ARG_OPTION_MSG)
        if(M_ARG_NAMESPACE)
            set(full_name "${NAMESPACE}::${comp_name}")
        else()
            set(full_name "${comp_name}")
        endif()
        set(M_ARG_OPTION_MSG "Build component ${full_name} or not.")
    endif()
    set_ifndef(M_ARG_OPTION_DEFAULT ON)
    option(${M_ARG_OPTION_NAME} ${M_ARG_OPTION_MSG} ${M_ARG_OPTION_DEFAULT})
    if(NOT ${M_ARG_OPTION_NAME} AND DEFINED M_ARG_RETURN_IF_NOT_BUILT)
        return()
    endif()
    set(COMPONENT_NAME "${comp_name}")
    set_ifndef(M_ARG_CODE_NAME "${comp_name}")
    set(COMPONENT_CODE_NAME "${M_ARG_CODE_NAME}")
    if(DEFINED M_ARG_OUT_VAR)
        set(${M_ARG_OUT_VAR} ${M_ARG_OPTION_NAME})
    endif()
endmacro()

function(_cmtk_set_semantic_version prefix basicver)
    # Args:
    set(options "")
    set(params "PRE_RELEASE;BUILD_METADATA")
    set(lists "")
    # Parse args:
    cmake_parse_arguments(PARSE_ARGV 0 "ARG" "${options}" "${params}" "${lists}")
    #:
    set(${prefix}_VERSION "${basicver}" PARENT_SCOPE)
    set(semantic_version "${basicver}")
    if(DEFINED ARG_PRE_RELEASE)
        string(APPEND semantic_version "-${ARG_PRE_RELEASE}")
    endif()
    if(DEFINED ARG_BUILD_METADATA)
        string(APPEND semantic_version "+${ARG_BUILD_METADATA}")
    endif()
    string(REPLACE "." ";" vlist "${basicver}")
    list(GET vlist 0 major)
    list(GET vlist 1 minor)
    list(GET vlist 2 patch)
    set(${prefix}_VERSION_MAJOR ${major} PARENT_SCOPE)
    set(${prefix}_VERSION_MINOR ${minor} PARENT_SCOPE)
    set(${prefix}_VERSION_PATCH ${patch} PARENT_SCOPE)
    set(${prefix}_VERSION_PRE_RELEASE "${ARG_PRE_RELEASE}" PARENT_SCOPE)
    set(${prefix}_VERSION_BUILD_METADATA "${ARG_BUILD_METADATA}" PARENT_SCOPE)
    set(${prefix}_SEMANTIC_VERSION "${semantic_version}" PARENT_SCOPE)
endfunction()

macro(set_project_semantic_version)
    _cmtk_set_semantic_version("PROJECT" ${ARGV})
endmacro()

macro(set_package_semantic_version)
    _cmtk_set_semantic_version("PACKAGE" ${ARGV})
endmacro()

function(configure_files return_var)
  cmake_parse_arguments(PARSE_ARGV 1 "ARG" "" "BASE_DIR;BINARY_BASE_DIR" "FILES")
  fatal_ifndef("You must provide files to configure (FILES)." ARG_FILES)
  fatal_ifndef("You must provide an source base directory (BASE_DIR)." ARG_BASE_DIR)
  fatal_ifndef("You must provide a binary base directory (BINARY_BASE_DIR)." ARG_BINARY_BASE_DIR)
  file(REAL_PATH ${ARG_BASE_DIR} ARG_BASE_DIR)
  foreach(ifile ${ARG_FILES})
    file(REAL_PATH ${ifile} ifile)
    file(RELATIVE_PATH orpath ${ARG_BASE_DIR} ${ifile})
    get_filename_component(orext ${orpath} LAST_EXT)
    if("${orext}" STREQUAL ".in")
      get_filename_component(ordir ${orpath} DIRECTORY)
      get_filename_component(orname ${orpath} NAME_WLE)
      set(orpath "${ordir}/${orname}")
    endif()
    set(oapath "${ARG_BINARY_BASE_DIR}/${orpath}")
    configure_file(${ifile} ${oapath})
    list(APPEND olist ${oapath})
  endforeach()
  set(${return_var} "${olist}" PARENT_SCOPE)
endfunction()

function(install_uninstall_script package_name)
    include(GNUInstallDirs)
    # Args:
    set(options "ALL")
    set(params "FILENAME;PACKAGE_DIR;VERSION")
    set(lists "")
    # Parse args:
    cmake_parse_arguments(PARSE_ARGV 1 "ARG" "${options}" "${params}" "${lists}")
    # Check args:
    set_ifndef(ARG_FILENAME "uninstall.cmake")
    set_ifndef(ARG_PACKAGE_DIR "${CMAKE_INSTALL_LIBDIR}/cmake/${package_name}")
    set_ifndef(ARG_VERSION "${PROJECT_VERSION}")
    set(rel_uninstall_path "${ARG_PACKAGE_DIR}/${ARG_FILENAME}")
    #
    set(uninstall_script_code "
        message(STATUS \"Installing: \${CMAKE_INSTALL_PREFIX}/${rel_uninstall_path}\")
        if(DEFINED CMAKE_INSTALL_MANIFEST_FILES)
            set(uninstall_script \${CMAKE_INSTALL_PREFIX}/${rel_uninstall_path})
            list(APPEND CMAKE_INSTALL_MANIFEST_FILES \${uninstall_script})
            set(files \${CMAKE_INSTALL_MANIFEST_FILES})
        ")
    if(ARG_ALL)
        string(APPEND uninstall_script_code "
            set(CMTK_INSTALL_FILES \${files})
            ")
    else()
        string(APPEND uninstall_script_code "
            if(CMTK_INSTALL_FILES)
                list(REMOVE_ITEM files \${CMTK_INSTALL_FILES})
            endif()
            list(APPEND CMTK_INSTALL_FILES \${files})
            ")
    endif()
    string(APPEND uninstall_script_code "
        file(APPEND \${CMAKE_INSTALL_PREFIX}/${rel_uninstall_path}
        \"
        message(STATUS \\\"Uninstall ${package_name} v${ARG_VERSION} ${CMAKE_BUILD_TYPE}\\\")
        foreach(file \${files})
            while(NOT \\\${file} STREQUAL \${CMAKE_INSTALL_PREFIX})
                if(EXISTS \\\${file} OR IS_SYMLINK \\\${file})
                    if(IS_DIRECTORY \\\${file})
                        file(GLOB dir_files \\\${file}/*)
                        list(LENGTH dir_files number_of_files)
                        if(\\\${number_of_files} EQUAL 0)
                          message(STATUS \\\"Removing  dir: \\\${file}\\\")
                          file(REMOVE_RECURSE \\\${file})
                        endif()
                    else()
                        message(STATUS \\\"Removing file: \\\${file}\\\")
                        file(REMOVE \\\${file})
                    endif()
                endif()
                get_filename_component(file \\\${file} DIRECTORY)
            endwhile()
        endforeach()
        \"
        )
    else()
        message(ERROR \"cmake_uninstall.cmake script cannot be created!\")
    endif()
        ")
    install(CODE ${uninstall_script_code})
endfunction()

function(clear_install_file_list)
    install(CODE "set(CMTK_INSTALL_FILES \${CMAKE_INSTALL_MANIFEST_FILES})")
endfunction()
